# backend/app/services/malware_scanner_service.py
"""
Production-grade malware scanning service using ClamAV
Provides multi-layered defense against malicious files
"""

import logging
import io
from typing import BinaryIO, Dict, Optional, List
import clamd
import PyPDF2
from PyPDF2 import PdfReader
from PyPDF2.errors import PdfReadError

logger = logging.getLogger(__name__)


class ScanResult:
    """Structured scan result with threat details"""

    def __init__(
        self,
        is_safe: bool,
        threats: Optional[List[str]] = None,
        warnings: Optional[List[str]] = None,
        scan_engine: Optional[str] = None,
        error: Optional[str] = None
    ):
        self.is_safe = is_safe
        self.threats = threats or []
        self.warnings = warnings or []
        self.scan_engine = scan_engine
        self.error = error


class MalwareScannerService:
    """
    Multi-layered malware detection service

    Layer 1: ClamAV antivirus scanning (signature-based)
    Layer 2: PDF structural validation (exploit detection)
    Layer 3: Office document macro detection
    """

    def __init__(self):
        self._clamav_client = None
        self._clamav_available = None

    def _get_clamav_client(self) -> Optional[clamd.ClamdUnixSocket]:
        """Lazy initialization of ClamAV client with fallback"""
        if self._clamav_available is False:
            return None

        if self._clamav_client is None:
            try:
                # Try TCP socket first (configured in Dockerfile)
                self._clamav_client = clamd.ClamdNetworkSocket(host='127.0.0.1', port=3310, timeout=30)
                # Test connection
                self._clamav_client.ping()
                self._clamav_available = True
                logger.info("ClamAV connection established via TCP socket")
            except Exception as e:
                logger.warning(f"ClamAV not available via TCP, trying Unix socket: {e}")
                try:
                    # Fallback to Unix socket
                    self._clamav_client = clamd.ClamdUnixSocket(timeout=30)
                    self._clamav_client.ping()
                    self._clamav_available = True
                    logger.info("ClamAV connection established via Unix socket")
                except Exception as e2:
                    logger.error(f"ClamAV not available: {e2}")
                    self._clamav_available = False
                    self._clamav_client = None

        return self._clamav_client

    async def scan_file(
        self,
        file_content: BinaryIO,
        filename: str,
        mime_type: Optional[str] = None
    ) -> ScanResult:
        """
        Comprehensive file scanning with multiple detection layers

        Args:
            file_content: File binary content
            filename: Original filename
            mime_type: MIME type (optional, for targeted scanning)

        Returns:
            ScanResult with threat analysis
        """
        all_threats = []
        all_warnings = []
        scan_engines = []

        try:
            # Layer 1: ClamAV signature-based scanning
            clamav_result = await self._scan_with_clamav(file_content)
            if not clamav_result.is_safe:
                all_threats.extend(clamav_result.threats)
            if clamav_result.warnings:
                all_warnings.extend(clamav_result.warnings)
            if clamav_result.scan_engine:
                scan_engines.append(clamav_result.scan_engine)

            # Layer 2: Document-specific structural validation
            if mime_type:
                if mime_type == 'application/pdf':
                    pdf_result = await self._validate_pdf_structure(file_content)
                    if not pdf_result.is_safe:
                        all_threats.extend(pdf_result.threats)
                    if pdf_result.warnings:
                        all_warnings.extend(pdf_result.warnings)
                    scan_engines.append("PDF Structure Validator")

                elif 'officedocument' in mime_type or 'msword' in mime_type:
                    office_result = await self._validate_office_document(file_content, mime_type)
                    if not office_result.is_safe:
                        all_threats.extend(office_result.threats)
                    if office_result.warnings:
                        all_warnings.extend(office_result.warnings)
                    scan_engines.append("Office Document Validator")

            # Determine overall safety
            is_safe = len(all_threats) == 0

            return ScanResult(
                is_safe=is_safe,
                threats=all_threats,
                warnings=all_warnings,
                scan_engine=", ".join(scan_engines) if scan_engines else "No scan engines available"
            )

        except Exception as e:
            logger.error(f"Malware scan error: {e}", exc_info=True)
            return ScanResult(
                is_safe=False,
                error=f"Scan failed: {str(e)}",
                scan_engine="Error"
            )

    async def _scan_with_clamav(self, file_content: BinaryIO) -> ScanResult:
        """Scan file with ClamAV antivirus engine"""
        clamav = self._get_clamav_client()

        if not clamav:
            logger.warning("ClamAV not available, skipping antivirus scan")
            return ScanResult(
                is_safe=True,
                warnings=["ClamAV antivirus not available - file not scanned for known malware"],
                scan_engine=None
            )

        try:
            # Read file content
            file_content.seek(0)
            file_data = file_content.read()
            file_content.seek(0)

            # Scan with ClamAV
            scan_result = clamav.instream(io.BytesIO(file_data))

            # Parse result
            # Result format: {'stream': ('FOUND', 'Malware.Name')} or {'stream': ('OK', None)}
            if 'stream' in scan_result:
                status, threat_name = scan_result['stream']

                if status == 'FOUND':
                    logger.warning(f"ClamAV detected threat: {threat_name}")
                    return ScanResult(
                        is_safe=False,
                        threats=[f"Malware detected: {threat_name}"],
                        scan_engine="ClamAV"
                    )
                elif status == 'OK':
                    return ScanResult(
                        is_safe=True,
                        scan_engine="ClamAV"
                    )
                else:
                    logger.warning(f"Unexpected ClamAV status: {status}")
                    return ScanResult(
                        is_safe=True,
                        warnings=[f"ClamAV returned unexpected status: {status}"],
                        scan_engine="ClamAV"
                    )
            else:
                logger.error(f"Unexpected ClamAV response format: {scan_result}")
                return ScanResult(
                    is_safe=True,
                    warnings=["ClamAV scan completed but result format unexpected"],
                    scan_engine="ClamAV"
                )

        except Exception as e:
            logger.error(f"ClamAV scan failed: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"ClamAV scan failed: {str(e)}"],
                scan_engine="ClamAV (Failed)"
            )

    async def _validate_pdf_structure(self, file_content: BinaryIO) -> ScanResult:
        """
        Validate PDF structure and check for exploit features

        Checks for:
        - Embedded JavaScript (can execute malicious code)
        - Embedded files (can hide executables)
        - Launch actions (can execute system commands)
        - Form actions (can trigger exploits)
        """
        threats = []
        warnings = []

        try:
            file_content.seek(0)
            pdf = PdfReader(file_content)
            file_content.seek(0)

            # Check for JavaScript (high risk)
            has_javascript = False
            for page_num in range(len(pdf.pages)):
                try:
                    page = pdf.pages[page_num]
                    page_obj = page.get_object()

                    # Check for JS in page annotations
                    if '/Annots' in page_obj:
                        annots = page_obj['/Annots']
                        if hasattr(annots, 'get_object'):
                            annots = annots.get_object()

                        for annot in annots if isinstance(annots, list) else []:
                            try:
                                annot_obj = annot.get_object() if hasattr(annot, 'get_object') else annot
                                if '/JS' in annot_obj or '/JavaScript' in annot_obj:
                                    has_javascript = True
                                    break
                            except:
                                pass

                    # Check for JS in page object
                    if '/JS' in page_obj or '/JavaScript' in page_obj:
                        has_javascript = True
                        break

                except Exception as e:
                    logger.debug(f"Error checking page {page_num} for JavaScript: {e}")

            if has_javascript:
                threats.append("PDF contains JavaScript (potential exploit vector)")

            # Check for embedded files
            catalog = pdf.trailer.get('/Root')
            if catalog:
                catalog_obj = catalog.get_object() if hasattr(catalog, 'get_object') else catalog
                if '/Names' in catalog_obj:
                    names = catalog_obj['/Names']
                    names_obj = names.get_object() if hasattr(names, 'get_object') else names
                    if '/EmbeddedFiles' in names_obj:
                        warnings.append("PDF contains embedded files")

            # Check for launch actions (very high risk)
            if '/AA' in pdf.trailer or '/OpenAction' in pdf.trailer:
                trailer_str = str(pdf.trailer)
                if '/Launch' in trailer_str:
                    threats.append("PDF contains launch actions (can execute system commands)")

            # Check for suspicious URIs
            for page_num in range(len(pdf.pages)):
                try:
                    page = pdf.pages[page_num]
                    page_str = str(page.get_object())
                    if '/URI' in page_str and ('cmd.exe' in page_str or 'powershell' in page_str):
                        threats.append("PDF contains suspicious URI actions")
                        break
                except:
                    pass

            is_safe = len(threats) == 0

            return ScanResult(
                is_safe=is_safe,
                threats=threats,
                warnings=warnings
            )

        except PdfReadError as e:
            logger.error(f"Invalid PDF structure: {e}")
            return ScanResult(
                is_safe=False,
                threats=["Invalid or corrupted PDF file"]
            )
        except Exception as e:
            logger.error(f"PDF validation error: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"PDF structure validation failed: {str(e)}"]
            )

    async def _validate_office_document(self, file_content: BinaryIO, mime_type: str) -> ScanResult:
        """
        Validate Office documents for macro threats

        Office documents can contain VBA macros that execute code
        """
        warnings = []
        threats = []

        try:
            file_content.seek(0)
            file_data = file_content.read()
            file_content.seek(0)

            # Check for VBA macro signatures in file content
            # Office Open XML files (.docx, .xlsx) store macros in vbaProject.bin
            if b'vbaProject.bin' in file_data:
                warnings.append("Office document contains VBA macros (potential risk)")

            # Check for old Office format macros
            if mime_type in ['application/msword', 'application/vnd.ms-excel', 'application/vnd.ms-powerpoint']:
                # Legacy Office formats can contain embedded macros
                if b'Macros' in file_data or b'VBA' in file_data:
                    warnings.append("Legacy Office document may contain macros")

            return ScanResult(
                is_safe=True,  # Macros are not inherently malicious, just risky
                warnings=warnings
            )

        except Exception as e:
            logger.error(f"Office document validation error: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"Office document validation failed: {str(e)}"]
            )

    async def get_scanner_status(self) -> Dict:
        """Get status of all scanning engines"""
        clamav = self._get_clamav_client()

        status = {
            'clamav': {
                'available': clamav is not None,
                'version': None
            },
            'pdf_validator': {
                'available': True,
                'version': PyPDF2.__version__
            }
        }

        if clamav:
            try:
                version = clamav.version()
                status['clamav']['version'] = version
            except:
                pass

        return status


# Global service instance
malware_scanner_service = MalwareScannerService()
