# backend/app/services/malware_scanner_service.py
"""
Production-grade malware scanning service using ClamAV
Provides multi-layered defense against malicious files
"""

import logging
import io
import time
from typing import BinaryIO, Dict, Optional, List
import clamd
import PyPDF2
from PyPDF2 import PdfReader
from PyPDF2.errors import PdfReadError

logger = logging.getLogger(__name__)


class ScanResult:
    """Structured scan result with threat details"""

    def __init__(
        self,
        is_safe: bool,
        threats: Optional[List[str]] = None,
        warnings: Optional[List[str]] = None,
        scan_engine: Optional[str] = None,
        error: Optional[str] = None,
        signature_scan_performed: bool = True
    ):
        self.is_safe = is_safe
        self.threats = threats or []
        self.warnings = warnings or []
        self.scan_engine = scan_engine
        self.error = error
        self.signature_scan_performed = signature_scan_performed


class MalwareScannerService:
    """
    Multi-layered malware detection service

    Layer 1: ClamAV antivirus scanning (signature-based)
    Layer 2: PDF structural validation (exploit detection)
    Layer 3: Office document macro detection
    """

    def __init__(self):
        self._clamav_client = None
        self._clamav_available = None
        self._last_connection_attempt = 0
        self._retry_interval = 60  # Only retry every 60 seconds to avoid hammering

    def _get_clamav_client(self) -> Optional[clamd.ClamdUnixSocket]:
        """
        Lazy initialization of ClamAV client with fallback and safe retry logic

        Retry Strategy:
        - If connection previously failed, only retry after 60 seconds
        - This prevents infinite loops and hammering ClamAV on every request
        - Allows eventual reconnection if ClamAV starts up later
        """
        current_time = time.time()

        # If we know it's unavailable, check if enough time has passed to retry
        if self._clamav_available is False:
            time_since_last_attempt = current_time - self._last_connection_attempt
            if time_since_last_attempt < self._retry_interval:
                # Too soon to retry, return None immediately
                return None
            else:
                # Enough time has passed, reset state and try again
                logger.info(f"Retrying ClamAV connection after {int(time_since_last_attempt)}s...")
                self._clamav_available = None
                self._clamav_client = None

        if self._clamav_client is None:
            self._last_connection_attempt = current_time

            try:
                # Try TCP socket first (configured in Dockerfile)
                self._clamav_client = clamd.ClamdNetworkSocket(host='127.0.0.1', port=3310, timeout=30)
                # Test connection
                self._clamav_client.ping()
                self._clamav_available = True
                logger.info("✓ ClamAV connection established via TCP socket")
            except Exception as e:
                logger.warning(f"ClamAV not available via TCP, trying Unix socket: {e}")
                try:
                    # Fallback to Unix socket
                    self._clamav_client = clamd.ClamdUnixSocket(timeout=30)
                    self._clamav_client.ping()
                    self._clamav_available = True
                    logger.info("✓ ClamAV connection established via Unix socket")
                except Exception as e2:
                    logger.warning(f"ClamAV not available: {e2}. Will retry in {self._retry_interval} seconds.")
                    self._clamav_available = False
                    self._clamav_client = None

        return self._clamav_client

    async def scan_file(
        self,
        file_content: BinaryIO,
        filename: str,
        mime_type: Optional[str] = None
    ) -> ScanResult:
        """
        Comprehensive file scanning with multiple detection layers

        Args:
            file_content: File binary content
            filename: Original filename
            mime_type: MIME type (optional, for targeted scanning)

        Returns:
            ScanResult with threat analysis
        """
        all_threats = []
        all_warnings = []
        scan_engines = []

        signature_scan_performed = True

        try:
            # Layer 1: ClamAV signature-based scanning
            clamav_result = await self._scan_with_clamav(file_content)
            signature_scan_performed = clamav_result.signature_scan_performed

            if not clamav_result.is_safe:
                all_threats.extend(clamav_result.threats)
            if clamav_result.warnings:
                all_warnings.extend(clamav_result.warnings)
            if clamav_result.scan_engine:
                scan_engines.append(clamav_result.scan_engine)

            # Layer 2: Document-specific structural validation
            if mime_type:
                if mime_type == 'application/pdf':
                    pdf_result = await self._validate_pdf_structure(file_content)
                    if not pdf_result.is_safe:
                        all_threats.extend(pdf_result.threats)
                    if pdf_result.warnings:
                        all_warnings.extend(pdf_result.warnings)
                    scan_engines.append("PDF Structure Validator")

                elif 'officedocument' in mime_type or 'msword' in mime_type:
                    office_result = await self._validate_office_document(file_content, mime_type)
                    if not office_result.is_safe:
                        all_threats.extend(office_result.threats)
                    if office_result.warnings:
                        all_warnings.extend(office_result.warnings)
                    scan_engines.append("Office Document Validator")

            # Determine overall safety
            # When signature scanning unavailable, be more strict: treat warnings as threats
            if not signature_scan_performed and len(all_warnings) > 0:
                # Without ClamAV, we can't verify that suspicious characteristics are safe
                # Promote warnings to threats for files with risky features
                logger.warning(
                    f"ClamAV unavailable - rejecting file with {len(all_warnings)} suspicious characteristics: {', '.join(all_warnings)}"
                )
                all_threats.extend([
                    f"File rejected due to suspicious characteristics (signature scanning unavailable): {w}"
                    for w in all_warnings
                ])
                all_warnings.clear()

            is_safe = len(all_threats) == 0

            # Log comprehensive scan summary
            engines_used = ", ".join(scan_engines) if scan_engines else "No scan engines available"
            if is_safe:
                scan_status = "with signature scanning" if signature_scan_performed else "WITHOUT signature scanning (heuristics only)"
                logger.info(f"✓ File scan completed successfully - File is SAFE {scan_status} | Engines: {engines_used} | Warnings: {len(all_warnings)}")
            else:
                logger.warning(f"✗ File scan completed - THREATS DETECTED: {len(all_threats)} | Engines: {engines_used}")

            return ScanResult(
                is_safe=is_safe,
                threats=all_threats,
                warnings=all_warnings,
                scan_engine=engines_used,
                signature_scan_performed=signature_scan_performed
            )

        except Exception as e:
            logger.error(f"Malware scan error: {e}", exc_info=True)
            # FAIL-CLOSED: Reject file if scanning system crashes
            return ScanResult(
                is_safe=False,
                threats=["Security scanning system error - file rejected for safety"],
                error=f"Scan failed: {str(e)}",
                scan_engine="Error",
                signature_scan_performed=False
            )

    async def _scan_with_clamav(self, file_content: BinaryIO) -> ScanResult:
        """Scan file with ClamAV antivirus engine"""
        clamav = self._get_clamav_client()

        if not clamav:
            logger.warning("ClamAV not available, skipping signature-based antivirus scan")
            return ScanResult(
                is_safe=True,
                warnings=["ClamAV antivirus not available - signature-based malware scanning skipped"],
                scan_engine=None,
                signature_scan_performed=False
            )

        try:
            # Read file content
            file_content.seek(0)
            file_data = file_content.read()
            file_content.seek(0)

            logger.info(f"Starting ClamAV antivirus scan on file ({len(file_data)} bytes)")

            # Scan with ClamAV
            scan_result = clamav.instream(io.BytesIO(file_data))

            # Parse result
            # Result format: {'stream': ('FOUND', 'Malware.Name')} or {'stream': ('OK', None)}
            if 'stream' in scan_result:
                status, threat_name = scan_result['stream']

                if status == 'FOUND':
                    logger.warning(f"ClamAV detected threat: {threat_name}")
                    return ScanResult(
                        is_safe=False,
                        threats=[f"Malware detected: {threat_name}"],
                        scan_engine="ClamAV"
                    )
                elif status == 'OK':
                    logger.info("✓ ClamAV scan completed successfully - no threats detected")
                    return ScanResult(
                        is_safe=True,
                        scan_engine="ClamAV"
                    )
                else:
                    logger.warning(f"Unexpected ClamAV status: {status}")
                    return ScanResult(
                        is_safe=True,
                        warnings=[f"ClamAV returned unexpected status: {status}"],
                        scan_engine="ClamAV"
                    )
            else:
                logger.error(f"Unexpected ClamAV response format: {scan_result}")
                return ScanResult(
                    is_safe=True,
                    warnings=["ClamAV scan completed but result format unexpected"],
                    scan_engine="ClamAV"
                )

        except Exception as e:
            logger.error(f"ClamAV scan failed: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"ClamAV scan failed: {str(e)}"],
                scan_engine="ClamAV (Failed)",
                signature_scan_performed=False
            )

    async def _validate_pdf_structure(self, file_content: BinaryIO) -> ScanResult:
        """
        Validate PDF structure and check for exploit features

        Checks for:
        - Embedded JavaScript (can execute malicious code)
        - Embedded files (can hide executables)
        - Launch actions (can execute system commands)
        - Form actions (can trigger exploits)
        """
        threats = []
        warnings = []

        try:
            file_content.seek(0)
            pdf = PdfReader(file_content)
            file_content.seek(0)

            # Check for JavaScript (high risk)
            has_javascript = False
            for page_num in range(len(pdf.pages)):
                try:
                    page = pdf.pages[page_num]
                    page_obj = page.get_object()

                    # Check for JS in page annotations
                    if '/Annots' in page_obj:
                        annots = page_obj['/Annots']
                        if hasattr(annots, 'get_object'):
                            annots = annots.get_object()

                        for annot in annots if isinstance(annots, list) else []:
                            try:
                                annot_obj = annot.get_object() if hasattr(annot, 'get_object') else annot
                                if '/JS' in annot_obj or '/JavaScript' in annot_obj:
                                    has_javascript = True
                                    break
                            except:
                                pass

                    # Check for JS in page object
                    if '/JS' in page_obj or '/JavaScript' in page_obj:
                        has_javascript = True
                        break

                except Exception as e:
                    logger.debug(f"Error checking page {page_num} for JavaScript: {e}")

            if has_javascript:
                threats.append("PDF contains JavaScript (potential exploit vector)")

            # Check for embedded files
            catalog = pdf.trailer.get('/Root')
            if catalog:
                catalog_obj = catalog.get_object() if hasattr(catalog, 'get_object') else catalog
                if '/Names' in catalog_obj:
                    names = catalog_obj['/Names']
                    names_obj = names.get_object() if hasattr(names, 'get_object') else names
                    if '/EmbeddedFiles' in names_obj:
                        warnings.append("PDF contains embedded files")

            # Check for launch actions (very high risk)
            if '/AA' in pdf.trailer or '/OpenAction' in pdf.trailer:
                trailer_str = str(pdf.trailer)
                if '/Launch' in trailer_str:
                    threats.append("PDF contains launch actions (can execute system commands)")

            # Check for suspicious URIs
            for page_num in range(len(pdf.pages)):
                try:
                    page = pdf.pages[page_num]
                    page_str = str(page.get_object())
                    if '/URI' in page_str and ('cmd.exe' in page_str or 'powershell' in page_str):
                        threats.append("PDF contains suspicious URI actions")
                        break
                except:
                    pass

            is_safe = len(threats) == 0

            return ScanResult(
                is_safe=is_safe,
                threats=threats,
                warnings=warnings
            )

        except PdfReadError as e:
            logger.error(f"Invalid PDF structure: {e}")
            return ScanResult(
                is_safe=False,
                threats=["Invalid or corrupted PDF file"]
            )
        except Exception as e:
            logger.error(f"PDF validation error: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"PDF structure validation failed: {str(e)}"]
            )

    async def _validate_office_document(self, file_content: BinaryIO, mime_type: str) -> ScanResult:
        """
        Validate Office documents for macro threats

        Office documents can contain VBA macros that execute code
        """
        warnings = []
        threats = []

        try:
            file_content.seek(0)
            file_data = file_content.read()
            file_content.seek(0)

            # Check for VBA macro signatures in file content
            # Office Open XML files (.docx, .xlsx) store macros in vbaProject.bin
            if b'vbaProject.bin' in file_data:
                warnings.append("Office document contains VBA macros (potential risk)")

            # Check for old Office format macros
            if mime_type in ['application/msword', 'application/vnd.ms-excel', 'application/vnd.ms-powerpoint']:
                # Legacy Office formats can contain embedded macros
                if b'Macros' in file_data or b'VBA' in file_data:
                    warnings.append("Legacy Office document may contain macros")

            return ScanResult(
                is_safe=True,  # Macros are not inherently malicious, just risky
                warnings=warnings
            )

        except Exception as e:
            logger.error(f"Office document validation error: {e}", exc_info=True)
            return ScanResult(
                is_safe=True,
                warnings=[f"Office document validation failed: {str(e)}"]
            )

    async def get_scanner_status(self) -> Dict:
        """Get status of all scanning engines"""
        clamav = self._get_clamav_client()

        status = {
            'clamav': {
                'available': clamav is not None,
                'version': None
            },
            'pdf_validator': {
                'available': True,
                'version': PyPDF2.__version__
            }
        }

        if clamav:
            try:
                version = clamav.version()
                status['clamav']['version'] = version
            except:
                pass

        return status


# Global service instance
malware_scanner_service = MalwareScannerService()
